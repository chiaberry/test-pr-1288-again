# MOPED Database

#### No Hasura Web Console?
The Hasura console is not available for MOPED. We are following
new best practices when it comes to production, which includes
a new migrations process.

With this new process, it is important to version-control any
changes made to the database, and having the Hasura console
available makes this difficult since anyone would be able
to go in and make those unauthorized changes.

#### The Hasura web console is only available locally!

The Hasura console is not totally gone, but from now on it will
require additional steps to be able to connect to the local,
staging and production Hasura instances. 

Basically, the way this works is by running a local web client
that connects to the remote Hasura servers. This client is available
when you install the Hasura CLI in your system.


#### Alright, how do I get started with Hasura?

Take at least one hour to read the documentation. It will be worth it.

1. Make sure you have docker & docker-compose installed.
2. Make sure you have the Hasura CLI installed.

#### Install Docker & Docker-Compose

Installing docker is not necessary for you to develop, but it is
greatly encouraged. Installing docker depends greatly on your environment
and it is beyond the scope of this document. In short, you will want to
install both docker and docker-compose.

>For detailed instructions on how to install docker and docker-compose,
>follow [their documentation](https://docs.docker.com/desktop/).

>Docker compose is not an official component of Docker, and often it
>must be installed separately. [More on this here](https://docs.docker.com/compose/install/). 
#### Install the Hasura CLI

The Hasura CLI is a requirement if you want to use the Hasura Web Console.
It is also a requirement if you want to work with migrations. 

If you have Windows or Linux, you will want to check the [Hasura CLI docs](https://hasura.io/docs/1.0/graphql/core/hasura-cli/index.html)
to get started. If you have a Mac, you may want to run this command:

```bash
$ curl -L https://github.com/hasura/graphql-engine/raw/stable/cli/get.sh | bash
```

Once you have it installed, check that it is running with this command:

```bash
# Command:
$ hasura version

# Example output:
INFO hasura cli                                    version=v1.3.2
```

## Introduction

In Hasura, the metadata can be exported as files as a representation of
the state of the database; however, you might want more granular
step-by-step checkpoints on the evolution of the state. This is the
main purpose of migrations, to make and track all the changes in the
database.

### Hasura Migrations - The Metadata

Whenever you do certain actions on the web console or via the API,
Hasura records it in the metadata catalogue which is a schema
called `hdb_catalog` in your Postgres database.

For example, if you track a table, a new entry is created in
the `hdb_catalog.hdb_table` table in Postgres. Similarly, there
are more tables in this schema to track relationships,
event triggers, functions and remote schemas.

All information in this schema can be exported as files. Export
options are available on the console, CLI and via the API.

These files when imported to an existing or new Hasura instance,
will clear out the `hdb_catalog` schema on that instance and
populates it again with the imported data. 

One thing to note is that all the Postgres resources the metadata
refers to should already exist when the import happens, otherwise
Hasura will throw an error.


### Hasura Migrations - Principles

In order to understand how migrations work, we have to understand
a couple principles:

1. Migrations are stored and applied as **steps** (or versions).
A migration step (or version) contains changes to the Postgres schema.

2. The migration version can store the **up migration** (creating
resources) and the **down migration** (deleting resources).

    > For example, migration version 1 can include the SQL statements
required to create a table called profile as the up migration and
SQL statements to drop this table as the down migration.

3. The migration versions can be automatically generated by the
Hasura console or can be written by hand. They are stored as SQL
files in a directory called migrations.

    > For more details on the format of these files, 
    refer to the [Migration file format documentation](https://hasura.io/docs/1.0/graphql/core/migrations/reference/migration-file-format.html#migration-file-format-v2)

### Hasura Migrations - Initialization (context)

Note that there is no need to run this step in this folder, it is only
necessary for new projects. It is included in here so that you may
understand how these files came to be.

In a new project, the first step to get started with Hasura migrations
is to capture the "initial state" of the database, including any existing
metadata, database structure, etc.

First, we need to create a workspace based on our endpoint:

```
$ hasura init new-hasura-project --endpoint http://your-hasura-endpoint --admin-secret <youradminsecret>

$ cd new-hasura-project
```

Next, we need to export the initial state of the database by
creating a initial point from the server: export the metadata:

```
$ hasura migrate create init --from-server --endpoint <...> --admin-secret <...>
$ hasura metadata export --endpoint <...> --admin-secret <...>
```

These commands generates a database project folder, which looks looks this:

```
new-hasura-project/
├── config.yaml
├── metadata
│   ├── actions.graphql
│   ├── actions.yaml
│   ├── allow_list.yaml
│   ├── cron_triggers.yaml
│   ├── functions.yaml
│   ├── query_collections.yaml
│   ├── remote_schemas.yaml
│   ├── tables.yaml
│   └── version.yaml
├── migrations
│   └── 1599845236313_init
│       └── up.sql
└── seeds

4 directories, 12 files
```

Notice there is a `config.yaml` file, here is where the connection
to the Hasura instance is stored. The `metadata` folder contains
the Hasura metadata information about your database. The `migrations`
folder contains folders, each represent a migration step (version).
Each version contains any up/down actions.

This is the example of the contents of the config.yaml file:

```
version: 2
endpoint: http://localhost:8080
admin_secret: abcdef1234567890
metadata_directory: metadata
actions:
  kind: synchronous
  handler_webhook_baseurl: http://localhost:3000
```

### Hasura Migrations - Application Principles

Since we already have a migrations project, all we need to worry about
is creating migrations and apply these changes safely. To understand
how these changes are applied, these are the basic principles:  

1. When someone executes `migrate apply` using the Hasura CLI, the CLI
will first read the migration files present in the current directory.

2. The CLI then contacts the configured Hasura Server and get the status
of all migrations applied to the server by reading the
`hdb_catalog.schema_migrations` table. Each row in this table denotes a
migration version that is already applied on the server.

3. By comparing these two sets of versions, the CLI derives which
versions are already applied and which are not. The CLI would then
go ahead and apply the migrations on the server. This is done by
executing the actions against the database through the **Hasura
metadata APIs**.

4. The default action of the `migrate apply` command is to execute
all the **up migrations**. In order to roll back changes, you would need
to execute **down migrations** using the `--down` flag on the CLI.

### Hasura Migrations - Migration File Format

These are the principles:

1. In short, migration files are pure SQL files.
2. Each migration file has the following format:
   ```
   <version>_<name>.{up|down}.sql
   ```
   >A version which is the Unix timestamp in nanoseconds when the
   >file was created is the first part. Followed by a name which is
   >either manually added or auto-generated by the console. The next
   >part indicates what step this is. If it is up, it means that this
   >is the forward step, e.g. creating a table. The down indicates
   >that it is the corresponding rollback step.

3. A migration SQL file can contain SQL statements which are executed
on the apply step of the migration.
4. The UP file contains any sql statements to be run by the apply command,
you can think of this as going UP one version. The SQL can create, update,
drop tables, rename resources, etc. Whatever is necessary to accomplish
the NEXT version.

5. The DOWN file contains any SQL statements to roll back this version.
It is a bit more complex because it has to change back any modifications
made by UP.

>For more details on the format of these files, 
>refer to the [Migration file format documentation](https://hasura.io/docs/1.0/graphql/core/migrations/reference/migration-file-format.html#migration-file-format-v2)

### Hasura Migrations - The Metadata directory

The following files will be generated in the metadata/ directory of your project.

- `version.yaml`: Contains the metadata version of the server
- `tables.yaml`: Contains the metadata related to tables
- `remote_schemas.yaml`: Contains the metadata related to remote schemas
- `functions.yaml`: Contains the metadata related to custom functions
- `allow_list.yaml`: Contains the metadata related to allow lists
- `actions.yaml`: Contains the metadata related to actions
- `actions.graphql`: Contains all the action definition and custom type definitions

>For more details on the format of these files, 
>refer to the [Metadata directory format documentation](https://hasura.io/docs/1.0/graphql/core/migrations/reference/metadata-format.html)

## Development

Before you get started creating migrations, make sure you have read
the entirety of the documentation prior to this section.

**IMPORTANT: Migrations are developed in the local host only. You do not
apply migrations directly against staging or production. Those migrations
are applied solely by the DevOps pipeline via CircleCI or GitHub Actions.**

#### Migration Development in Localhost

Branching in localhost is the only way to safely develop migrations.

To create or review a migration:

1. Create a branch (`git branch your-branch-name`). If you are reviewing
a migration, update and check out the branch (`git checkout the-branch-name`).   
1. Run the local hasura cluster, enter `./hasura-cluster.sh start` and
wait until you see a "migrations finished" message.
1. Once the servers are ready, you may run `./hasura-cluster.sh console`
or `hasura console --endpoint http://localhost:8080`. Proceed to make
changes to the database, the migration files will be generated. If you are
reviewing the branch, you may do so here. Make sure there are no errors
in the terminal, and that the functionality is there.
1. Save and commit your migration files, then push your changes to your 
branch in github and make it a PR (no worries, PRs in the database
are ignored/not built). If you are reviewing, here is where you make
your observations and provide your approval if merited.
1. Wait until another dev downloads your branch, applies your migrations
and makes sure it is safe to be merged to staging.


Once the PR branch is reviewed, then it can be merged to master where
CircleCI will run the new migration against staging. If the PR is merged
against production, then CircleCI will do its thing against production.

## Migration DevOps

Hasura ships a special Docker image which can be used to automatically apply migrations/metadata when the server starts:

```
hasura/graphql-engine:<version>.cli-migrations-v2
```

This container image includes the Hasura CLI at /bin/hasura-cli and can
be used for running any other CI/CD scripts in your workflow.

### Migration DevOps - Applying Migrations

The migrations and metadata directories created by the Hasura CLI in a Hasura project can be mounted at the /hasura-migrations and /hasura-metadata path of this Docker container and the container’s entry point script will apply the migrations and metadata before starting the server. If no directory is mounted at the designated paths, the server will start ignoring the migrations and/or metadata.

If you want to mount the migrations/metadata directories at some location other than the above, set the following environment variables:

```bash
HASURA_GRAPHQL_MIGRATIONS_DIR=/custom-path-for-migrations
HASURA_GRAPHQL_METADATA_DIR=/custom-path-for-metadata
```

Once the migrations and metadata are applied, the container resumes operation as a normal Hasura GraphQL engine server.

```bash
# Start Hasura after applying the migrations and metadata present in the Hasura project
docker run -p 8080:8080 \
       -v /home/me/my-project/migrations:/hasura-migrations \
       -v /home/me/my-project/metadata:/hasura-metadata \
       -e HASURA_GRAPHQL_DATABASE_URL=postgres://postgres:@postgres:5432/postgres \
       hasura/graphql-engine:v1.2.0.cli-migrations-v2
```

### Migration DevOps - Applying only metadata

If you’re managing migrations with a different tool and want to use
this image to apply only the metadata, mount the metadata directory
of your Hasura project at the /hasura-metadata path of this Docker
container the container’s entry point script will apply the metadata
before starting the server.

